// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model

ROOST_METHOD_HASH=write_06450c78e2
ROOST_METHOD_SIG_HASH=write_5fbc39c8ba

**Scenario 1: Writing a Carriage Return Character**

Details:
TestName: writeCarriageReturn
Description: This test verifies that when the input byte is a carriage return ('\r'), the method outputs the CRLF sequence instead of just '\r'.
Execution:
Arrange: Initialize a ByteArrayOutputStream to capture the output.
Act: Call the `write` method with '\r' as the argument.
Assert: Check if the output stream received the bytes corresponding to CRLF.
Validation:
The assertion confirms that for every carriage return input, the method transforms it to a CRLF sequence. This test validates the method's behavior of ensuring consistent line terminators across platforms, which is crucial for text data transmitted over the Internet.

**Scenario 2: Writing a Line Feed Character Following a Carriage Return**

Details:
TestName: writeLineFeedAfterCarriageReturn
Description: This test checks the method's behavior when a line feed ('\n') immediately follows a carriage return ('\r'). The expected behavior is that the line feed is ignored as the CRLF has already been written.
Execution:
Arrange: Initialize a ByteArrayOutputStream to capture the output.
Act: Call the `write` method first with '\r' and then with '\n'.
Assert: Verify that the output stream received only one CRLF sequence.
Validation:
The assertion ensures that the method correctly ignores a '\n' following a '\r', preventing duplicate line terminators. This test is significant for maintaining the integrity of data formatting across different systems.

**Scenario 3: Writing a Line Feed Character Not Preceded by a Carriage Return**

Details:
TestName: writeLineFeedWithoutCarriageReturn
Description: Tests that a lone '\n' (not preceded by '\r') results in a CRLF sequence being written.
Execution:
Arrange: Create a ByteArrayOutputStream to capture the output.
Act: Invoke the `write` method with '\n' as the parameter.
Assert: Check that the output contains the bytes for CRLF.
Validation:
The assertion checks that '\n' alone is converted to CRLF, ensuring consistent line terminator sequences across different platforms, which is essential for the correct transmission and reading of data.

**Scenario 4: Writing a Non-Newline Character**

Details:
TestName: writeNonNewlineCharacter
Description: Ensures that any character other than '\r' or '\n' is written to the output as-is.
Execution:
Arrange: Set up a ByteArrayOutputStream to capture the output.
Act: Call the `write` method with a character such as 'a' (ASCII 97).
Assert: Confirm that the output stream received the byte 97.
Validation:
This assertion verifies that normal characters are passed through without alteration, which is critical for the integrity of non-control data within streams.

**Scenario 5: IOException Handling**

Details:
TestName: writeIOExceptionHandling
Description: Verifies that an IOException is properly thrown if an underlying write operation fails.
Execution:
Arrange: Use a mock OutputStream that throws IOException when written to.
Act: Attempt to write any byte using the `write` method.
Assert: Expect an IOException to be thrown.
Validation:
The test confirms the method's robustness by ensuring it correctly propagates exceptions from underlying I/O operations, which is essential for error handling in real-world applications.
*/

// ********RoostGPT********

package net.markenwerk.utils.mail.smime;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.mockito.Mockito;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import org.junit.jupiter.api.*;
import java.io.ByteArrayInputStream;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;

public class MimeUtilWriteTest {

	@Test
	@Tag("valid")
	public void writeCarriageReturn() throws IOException {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		MimeUtil mimeUtil = new MimeUtil(out);
		mimeUtil.write('\r');
		assertArrayEquals(new byte[] { '\r', '\n' }, out.toByteArray());
	}

	@Test
	@Tag("valid")
	public void writeLineFeedAfterCarriageReturn() throws IOException {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		MimeUtil mimeUtil = new MimeUtil(out);
		mimeUtil.write('\r');
		mimeUtil.write('\n');
		assertArrayEquals(new byte[] { '\r', '\n' }, out.toByteArray());
	}

	@Test
	@Tag("valid")
	public void writeLineFeedWithoutCarriageReturn() throws IOException {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		MimeUtil mimeUtil = new MimeUtil(out);
		mimeUtil.write('\n');
		assertArrayEquals(new byte[] { '\r', '\n' }, out.toByteArray());
	}

	@Test
	@Tag("valid")
	public void writeNonNewlineCharacter() throws IOException {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		MimeUtil mimeUtil = new MimeUtil(out);
		mimeUtil.write('a');
		assertArrayEquals(new byte[] { 97 }, out.toByteArray());
	}

	@Test
	@Tag("integration")
	public void writeIOExceptionHandling() throws IOException {
		OutputStream mockOut = Mockito.mock(OutputStream.class);
		Mockito.doThrow(IOException.class).when(mockOut).write(Mockito.anyInt());
		MimeUtil mimeUtil = new MimeUtil(mockOut);
		assertThrows(IOException.class, () -> mimeUtil.write('a'));
	}

}