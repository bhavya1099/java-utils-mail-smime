// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model

ROOST_METHOD_HASH=canonicalize_3ef2041d22
ROOST_METHOD_SIG_HASH=canonicalize_78914c8916

```
Scenario 1: Valid MimeBodyPart with simple content

Details:
  TestName: testCanonicalizeWithSimpleContent
  Description: Test the canonicalize method with a MimeBodyPart containing simple text content to ensure it correctly processes and returns a new MimeBodyPart with identical content in canonical form.
Execution:
  Arrange: Create a MimeBodyPart and set its content to a simple string, such as "Hello, World!" with a "text/plain" MIME type.
  Act: Invoke the canonicalize method on the created MimeBodyPart.
  Assert: Compare the content of the returned MimeBodyPart with the original content to ensure they are identical.
Validation:
  The assertion checks that the method correctly preserves the content of the MimeBodyPart while potentially modifying its format to a canonical form. This is crucial for ensuring data integrity when processing MIME body parts.

Scenario 2: MimeBodyPart with headers

Details:
  TestName: testCanonicalizeWithHeaders
  Description: Validate that the canonicalize method preserves headers of the MimeBodyPart after processing.
Execution:
  Arrange: Create a MimeBodyPart, set some headers (e.g., Content-Type, Content-Disposition), and some textual content.
  Act: Invoke the canonicalize method on this MimeBodyPart.
  Assert: Verify that the headers of the returned MimeBodyPart match the headers of the original MimeBodyPart.
Validation:
  This test ensures that headers are not lost or modified during the canonicalization process, which is essential for maintaining metadata about the MIME content.

Scenario 3: Empty MimeBodyPart

Details:
  TestName: testCanonicalizeEmptyMimeBodyPart
  Description: Test the canonicalize method with an empty MimeBodyPart to check how it handles lack of content.
Execution:
  Arrange: Create an empty MimeBodyPart.
  Act: Invoke the canonicalize method on the empty MimeBodyPart.
  Assert: Check that the returned MimeBodyPart is also empty.
Validation:
  This test verifies that the method can handle empty inputs without errors and that the output is consistent with the input, which is important for robustness.

Scenario 4: MimeBodyPart throws IOException

Details:
  TestName: testCanonicalizeWithIOException
  Description: Test the canonicalize method's error handling when an IOException is thrown during the writing process.
Execution:
  Arrange: Create a MimeBodyPart and mock its writeTo method to throw an IOException.
  Act: Try to invoke the canonicalize method and catch the expected IOException.
  Assert: Ensure that the IOException is thrown.
Validation:
  This test checks that the method correctly propagates IOExceptions, which is necessary for proper error handling in upstream processes.

Scenario 5: MimeBodyPart throws MessagingException

Details:
  TestName: testCanonicalizeWithMessagingException
  Description: Ensure that the canonicalize method properly handles a MessagingException thrown during processing.
Execution:
  Arrange: Create a MimeBodyPart and mock its writeTo method to throw a MessagingException.
  Act: Try to invoke the canonicalize method and catch the expected MessagingException.
  Assert: Verify that the MessagingException is thrown.
Validation:
  This test ensures that MessagingExceptions are not suppressed or incorrectly handled, maintaining the integrity of error management within the application.
```
*/

// ********RoostGPT********

package net.markenwerk.utils.mail.smime;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.junit.jupiter.api.*;
import java.io.OutputStream;

public class MimeUtilCanonicalize226Test {

	@Test
	@Tag("valid")
	public void testCanonicalizeWithSimpleContent() throws MessagingException, IOException {
		MimeBodyPart original = new MimeBodyPart();
		original.setText("Hello, World!", "UTF-8");
		MimeBodyPart result = MimeUtil.canonicalize(original);
		ByteArrayOutputStream originalStream = new ByteArrayOutputStream();
		ByteArrayOutputStream resultStream = new ByteArrayOutputStream();
		original.writeTo(originalStream);
		result.writeTo(resultStream);
		assertEquals(new String(originalStream.toByteArray()), new String(resultStream.toByteArray()));
	}

	@Test
	@Tag("valid")
	public void testCanonicalizeWithHeaders() throws MessagingException, IOException {
		MimeBodyPart original = new MimeBodyPart();
		original.setContent("Sample text", "text/plain");
		original.setHeader("Content-Type", "text/plain");
		original.setHeader("Content-Disposition", "attachment; filename=\"sample.txt\"");
		MimeBodyPart result = MimeUtil.canonicalize(original);
		assertEquals(original.getHeader("Content-Type")[0], result.getHeader("Content-Type")[0]);
		assertEquals(original.getHeader("Content-Disposition")[0], result.getHeader("Content-Disposition")[0]);
	}

	@Test
	@Tag("boundary")
	public void testCanonicalizeEmptyMimeBodyPart() throws MessagingException, IOException {
		MimeBodyPart original = new MimeBodyPart();
		MimeBodyPart result = MimeUtil.canonicalize(original);
		ByteArrayOutputStream originalStream = new ByteArrayOutputStream();
		ByteArrayOutputStream resultStream = new ByteArrayOutputStream();
		original.writeTo(originalStream);
		result.writeTo(resultStream);
		assertEquals(new String(originalStream.toByteArray()), new String(resultStream.toByteArray()));
	}

	@Test
	@Tag("invalid")
	public void testCanonicalizeWithIOException() throws MessagingException, IOException {
		MimeBodyPart original = mock(MimeBodyPart.class);
		doThrow(new IOException()).when(original).writeTo(Mockito.any());
		boolean exceptionCaught = false;
		try {
			MimeUtil.canonicalize(original);
		}
		catch (IOException e) {
			exceptionCaught = true;
		}
		assertTrue(exceptionCaught);
	}

	@Test
	@Tag("invalid")
	public void testCanonicalizeWithMessagingException() throws MessagingException, IOException {
		MimeBodyPart original = mock(MimeBodyPart.class);
		doThrow(new MessagingException()).when(original).writeTo(Mockito.any());
		boolean exceptionCaught = false;
		try {
			MimeUtil.canonicalize(original);
		}
		catch (MessagingException e) {
			exceptionCaught = true;
		}
		assertTrue(exceptionCaught);
	}

}