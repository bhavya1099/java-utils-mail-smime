// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model

ROOST_METHOD_HASH=write_f60797a75a
ROOST_METHOD_SIG_HASH=write_6f2f269543

Scenario 1: Write with a valid byte array

Details:
  TestName: writeWithValidByteArray
  Description: This test verifies that the write method handles a valid byte array correctly without throwing an exception.
Execution:
  Arrange: Create a non-empty byte array.
  Act: Call the write method with the created byte array.
  Assert: Verify that no exceptions are thrown and the byte array is written correctly to the output.
Validation:
  This assertion checks that the method can handle typical input correctly. It's significant because it confirms the method's ability to perform its primary function under normal conditions.

Scenario 2: Write with a null byte array

Details:
  TestName: writeWithNullByteArray
  Description: This test checks how the write method handles a null input, expecting it to throw a NullPointerException.
Execution:
  Arrange: Pass a null byte array to the write method.
  Act: Invoke the write method with the null byte array.
  Assert: Expect a NullPointerException to be thrown.
Validation:
  The test validates that the method throws an appropriate exception when given invalid input (null), which is crucial for avoiding undefined behaviors in the application.

Scenario 3: Write with an empty byte array

Details:
  TestName: writeWithEmptyByteArray
  Description: This test ensures that the write method can handle an empty byte array without errors and doesn't perform any operation.
Execution:
  Arrange: Create an empty byte array.
  Act: Call the write method with the empty byte array.
  Assert: Verify that no exceptions are thrown and no data is written.
Validation:
  This test checks the method's robustness with edge case inputs, ensuring that it gracefully handles cases where there's nothing to write, without causing errors.

Scenario 4: Write with maximum array length

Details:
  TestName: writeWithMaxArrayLength
  Description: This test checks the capability of the write method to handle a byte array of maximum possible length.
Execution:
  Arrange: Create a byte array filled with the maximum size allowed by the JVM.
  Act: Call the write method with this large byte array.
  Assert: Verify that no exceptions are thrown and the data is written correctly.
Validation:
  This test is important to assess the method's performance and behavior under stress conditions, ensuring it can handle large data sizes without failure.

Scenario 5: Write throws IOException

Details:
  TestName: writeThrowsIOException
  Description: This test ensures that the method properly propagates IOExceptions thrown by underlying output operations.
Execution:
  Arrange: Set up a scenario where the underlying OutputStream would throw an IOException (using mocks or a special test OutputStream).
  Act: Call the write method and expect it to propagate the IOException.
  Assert: Verify that an IOException is thrown.
Validation:
  The test confirms that IOExceptions are not swallowed or incorrectly handled, which is crucial for proper error handling and recovery in applications that use this method.
*/

// ********RoostGPT********

package net.markenwerk.utils.mail.smime;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.*;
import java.io.ByteArrayInputStream;
import java.io.OutputStream;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;

public class MimeUtilWrite667Test {

	@Test
	@Tag("valid")
	public void writeWithValidByteArray() {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		MimeUtil mimeUtil = new MimeUtil(out);
		byte[] input = "test data".getBytes();

		assertDoesNotThrow(() -> mimeUtil.write(input));
		assertArrayEquals(input, out.toByteArray());
	}

	@Test
	@Tag("invalid")
	public void writeWithNullByteArray() {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		MimeUtil mimeUtil = new MimeUtil(out);

		assertThrows(NullPointerException.class, () -> mimeUtil.write(null));
	}

	@Test
	@Tag("boundary")
	public void writeWithEmptyByteArray() {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		MimeUtil mimeUtil = new MimeUtil(out);
		byte[] input = new byte[0];

		assertDoesNotThrow(() -> mimeUtil.write(input));
		assertEquals(0, out.size());
	}

	@Test
	@Tag("boundary")
	public void writeWithMaxArrayLength() {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		MimeUtil mimeUtil = new MimeUtil(out);
		byte[] input = new byte[Integer.MAX_VALUE - 8]; // Adjusting to avoid
														// OutOfMemoryError
		assertDoesNotThrow(() -> mimeUtil.write(input));
		assertEquals(input.length, out.size());
	}

	@Test
	@Tag("integration")
	public void writeThrowsIOException() {
		ByteArrayOutputStream out = new ByteArrayOutputStream() {
			@Override
			public void write(byte[] b, int off, int len) throws IOException {
				throw new IOException("Forced IOException");
			}
		};
		MimeUtil mimeUtil = new MimeUtil(out);
		byte[] input = "test data".getBytes();

		assertThrows(IOException.class, () -> mimeUtil.write(input));
	}

}